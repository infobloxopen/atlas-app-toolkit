# Description

The common interfaces, types and helper functions to work with identifiers are defined in [resource](resource.go) file.

There are also some common implementations. 

# Codecs

The [fqstring](fqstring/codec.go) package provides a codec to encode and decode [atlas.rpc.Identifier](../../rpc/resource/resource.proto) 
to and from `driver.Value`.
The implementation converts `infoblox.rpc.Identifier` to a single string delimited by `/` (in **f**ully **q**ualified form).

The [uuid](uuid/codec.go) package provides a codec to encode and decode [atlas.rpc.Identifier](../../rpc/resource/resource.proto) 
to and from `driver.Value`.
The implementation validates that `resource_id` is a string in `UUID` format. If `resource_id` is not provided the empty string is returned.
Could be used for `uuid` primary keys with default value generated by SQL engine.

The [integer](integer/codec.go) package provides a codec to encode and decode [atlas.rpc.Identifier](../../rpc/resource/resource.proto) 
to and from `driver.Value`.
The implementation validates that `resource_id` is an integer value. If `resource_id` is not provided the `0` is returned.
Could be used for `serial` primary keys with default value generated by SQL engine.

Please see [example](example_test.go) to see how to register codecs and encode/decode identifiers based on resource types of proto messages.

# protoc-gen-gorm

The plugin has support of `atlas.rpc.Identifier` for **all** association types. All you need is to define your Primary/Foreign keys as
a fields of `atlas.rpc.Identifier` type.

In the `XxxORM` generated models `atlas.rpc.Identifier` will be replaced to the type specified in `(gorm.field).tag` option.
The only numeric and text formats are supported. If type is not set it will be generated as `interface{}`.
**NOTE** Be sure to set type properly for association fields.

Let's define some PB resources
```proto
syntax = "proto3";

import "github.com/infobloxopen/atlas-app-toolkit/rpc/resource/resource.proto";
import "github.com/infobloxopen/protoc-gen-gorm/options/gorm.proto";

option go_package = "github.com/yourapp/pb;pb";

message A {
    option (gorm.opts).ormable = true;
    
    infoblox.rpc.Identifier id = 1 [(gorm.field).tag = {type: "integer"}];
    string value = 2;
    repeated B b_list = 3; // has many
    infoblox.rpc.Identifier external = 4 [(gorm.field).tag = {type: "text"}];
}

message B {
    option (gorm.opts).ormable = true;
    
    infoblox.rpc.Identifier id = 1 [(gorm.field).tag = {type: "integer"}];
    string value = 2;
     // foreign key to A  parent. !!! Will be set to the type of A.id
     infoblox.rpc.Identifier a_id = 3;
}
```

In JSON it could look like
```json
{
  "id": "someapp/resource:a/1",
  "value": "someAvalue",
  "b_list": [
    {
      "id": "someapp/resource:b/1",
      "value": "someBvalue",
      "a_id": "someapp/resource:a/1"
    }
  ]
}
```

The generated code could be:
```go
import "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"

type AORM struct {
	Id int64
	Value string
	BList []*BORM
	External string
}

type BORM struct {
	Id int64
	Value string
	AId *int64
}
```

And then you need to register codecs in your `main.go` file, for example
```go
package main

import "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"
import "github.com/infobloxopen/atlas-app-toolkit/gorm/resource/integer"
import "github.com/infobloxopen/atlas-app-toolkit/gorm/resource/fqstring"
import "github.com/yourapp/pb"

func main() {
	resource.RegisterCodec(integer.NewCodec("someapp", "resource:a"), &pb.A{})
	resource.RegisterCodec(integer.NewCodec("someapp", "resource:b"), &pb.B{})
	// register codec for external identifiers
	resource.RegisterCodec(fqstring.NewCodec(), nil) // nil means for all references that do not have internal PB type
}
```
